/* START ALIGNMENT SETTINGS */

if (!_HY_NUC_CODON_HAVE_SCORE_MATRIX || Type(scoreMatrix)!="Matrix" || Rows (scoreMatrix) != 64)
{
	LoadFunctionLibrary ("chooseGeneticCode");
	LoadFunctionLibrary ("SeqAlignShared");
	alignOptions ["SEQ_ALIGN_CHARACTER_MAP"]="ACGT";
	LoadFunctionLibrary ("GrabBag");
	protScoreMatrix = alignOptions["SEQ_ALIGN_SCORE_MATRIX"];
	alignOptions = {};
	
    
 	protLetters = "ARNDCQEGHILKMFPSTWYV";
   _cdnaln_cdnScoreMatrix = pSM2cSM(protScoreMatrix, protLetters);
	
	
	alignOptions ["SEQ_ALIGN_SCORE_MATRIX"] = 	_cdnaln_cdnScoreMatrix;
	maxScore = Max (protScoreMatrix,0);
	minScore = Min (protScoreMatrix,0);
	
	alignOptions ["SEQ_ALIGN_GAP_OPEN"]		= 	4*Max(maxScore,-minScore);
	alignOptions ["SEQ_ALIGN_GAP_OPEN2"]	= 	Max(maxScore,-minScore);
	alignOptions ["SEQ_ALIGN_GAP_EXTEND"]	= 	1;
	alignOptions ["SEQ_ALIGN_GAP_EXTEND2"]	= 	1;
	alignOptions ["SEQ_ALIGN_FRAMESHIFT"]	= 	2*Max(maxScore,-minScore);
	alignOptions ["SEQ_ALIGN_CODON_ALIGN"]	= 	1;
	alignOptions ["SEQ_ALIGN_CHARACTER_MAP"]=  "ACGT";
   
    _cdnaln_partialScoreMatrices = cSM2partialSMs(_cdnaln_cdnScoreMatrix,0);
    
    alignOptions ["SEQ_ALIGN_PARTIAL_3x1_SCORES"] = _cdnaln_partialScoreMatrices["3x1"];
    alignOptions ["SEQ_ALIGN_PARTIAL_3x2_SCORES"] = _cdnaln_partialScoreMatrices["3x2"];
    alignOptions ["SEQ_ALIGN_PARTIAL_3x4_SCORES"] = _cdnaln_partialScoreMatrices["3x4"];
    alignOptions ["SEQ_ALIGN_PARTIAL_3x5_SCORES"] = _cdnaln_partialScoreMatrices["3x5"];
        
}

function Uppercase( _str )
{
    _upstr = _str && 1;
    _upstr * 0;
    return _upstr;
}

function CleanAlignment( _aln, _keepIns )
/*
 * Given the raw alignment record from AlignSequence, clean the aligned sequence and return either the raw sequence or the list of positions by CSV
 * @param  _aln 		-- the alignment dictionary
 * @param  _keepIns 	-- whether or not to keep insertions in the REFERENCE (0/1)
 * @return the cleaned string
 */
{

    _ref = ( _aln[0] )[1];
    _seq = ( _aln[0] )[2];
    _altRef = _ref ^ {{ "[a-z]", "_" }};
    _newRef = "";
    _newStr = "";
    _newRef * 256;
    _newStr * 256;
    if ( _keepIns ) {
        _keepIns = 1;
    } else {
        _keepIns = 0;
    }
    _k = 0;
    _overlap_count = 0;

    // codon by codon...
    _nucLen = Abs( _ref ^ {{ "[-]", "" }} );
    for ( _l = 0; _l < _nucLen; _l += 3 ) {
        _ins = 0;
        _dels = 0;
        // count the number of insertions and deletions
        _cdnAdv = Min( 3, _nucLen - _l );
        for ( _k2 = 0; _k2 < _cdnAdv; _k2 += 1 ) {
            if ( _altRef[ _k+_k2 ] == "-" ) {
                _ins += 1;
            } else {
                if ( _altRef[ _k+_k2 ] == "_" ) {
                    _dels += 1;
                }
            }
        }
        // if _ins == 3 (and we want to keep inserts),
        // then we have a full codon insertion,
        // add the original characters back in
        // if _ins == 0 and _dels == 0, then everything is normal,
        // add the original characters back in
        if ( ( _keepIns * _ins ) == 3 || ( _ins == 0 && _dels == 0 ) ) {
            _newRef * _ref[ _k ][ _k+2 ];
            _newStr * _seq[ _k ][ _k+2 ];

            _overlap_count += 3 * ( _seq[ _k ][ _k+2 ] != "---" );
            
            _k += 3;
        }
        // if neither of those two cases is true, then we need to go
        // position by position, removing insertions and
        // fixing deletions by adding in a "N"
        else {
            // _k2 advances by only a single codon (3 positions), whereas
            // _l2 moves us ahead in the alignment. At the end, the difference
            // between _k2 and _l2 should be that _l2 is greater by the number
            // of inserted nucleotides
            _k2 = 0;
            for ( _l2 = 0; _k2 < _cdnAdv; _l2 += 1 ) {
                // "_" means a deletion, add an "N" back in
                if ( _altRef[ _k+_l2 ] == "_" ) {
                    _newRef * _ref[ _k+_l2 ];
                    _newStr * "-"; // we used to add an N here, but that was controversial

                    _k2 += 1;
                }
                // if the character isn't an insertion
                // which it always isn't because we took care of
                // insertions above, add the original back in
                else {
                    if ( _altRef[ _k+_l2 ] != "-" ) {
                        _newRef * _ref[ _k+_l2 ];
                        _newStr * _seq[ _k+_l2 ];

                        _overlap_count += ( _seq[ _k+_l2 ] != "-" );
                        
                        _k2 += 1;
                    }
                }
            }
            _k += _l2;
        }
    }
    // only uppercase when not keeping inserts
    if ( _keepIns ) {
        _rest = Abs( _seq ) - _k;
        for ( _k2 = 0; _k2 < _rest; _k2 += 1 ) {
            _newRef * "-";
            _newStr * _seq[ _k+_k2 ];
        }
    } else {
        _newRef = Uppercase( _newRef );
        _newStr = Uppercase( _newStr );
    }
    _newRef * 0;
    _newStr * 0;
    // get rid of any gaps
    // _newStr2 = _newStr^{{"[-]", ""}};
    return { "ref": _newRef, 
             "seq": _newStr, 
             "overlap": _overlap_count / 3 };
}

function cSM2partialSMs(_cdnScoreMatrix, penalties)
{
    m3x5  =  { 65, 640 };
    m3x4  =  { 65, 256 };
    m3x2  =  { 65,  48 };
    m3x1  =  { 65,  12 };

    // minor penalties to make mismatch not entirely free
    
    if (Rows(penalties)*Columns(penalties) == 4) {
        p3x1 = penalties [0];
        p3x2 = penalties [1];
        p3x4 = penalties [2];
        p3x5 = penalties [3];
    } else {    
        p3x5 = 0;
        p3x4 = 0;
        p3x2 = 0;
        p3x1 = 0;
    }
    for ( thisCodon = 0; thisCodon < 64; thisCodon += 1 ) {
        for ( d1 = 0; d1 < 4; d1 += 1 ) {
            max100 = -1e100;
            max010 = -1e100;
            max001 = -1e100;

            for ( d2 = 0; d2 < 4; d2 += 1 ) {
                partialCodon = 4 * d1 + d2;
                max110 = -1e100;
                max101 = -1e100;
                max011 = -1e100;

                for ( d3 = 0; d3 < 4; d3 += 1 ) {
                    thisCodon2 = 4 * partialCodon + d3;
                    thisScore = _cdnScoreMatrix[ thisCodon ][ thisCodon2 ];

                    // this is the trivial and stupid way of doing it, but it should work
                    m3x5[ thisCodon ][ 10 * thisCodon2 + 0 ] = thisScore - p3x5;
                    m3x5[ thisCodon ][ 10 * thisCodon2 + 1 ] = thisScore - p3x5;
                    m3x5[ thisCodon ][ 10 * thisCodon2 + 2 ] = thisScore - p3x5;
                    m3x5[ thisCodon ][ 10 * thisCodon2 + 3 ] = thisScore - p3x5;
                    m3x5[ thisCodon ][ 10 * thisCodon2 + 4 ] = thisScore - p3x5;
                    m3x5[ thisCodon ][ 10 * thisCodon2 + 5 ] = thisScore - p3x5;
                    m3x5[ thisCodon ][ 10 * thisCodon2 + 6 ] = thisScore - p3x5;
                    m3x5[ thisCodon ][ 10 * thisCodon2 + 7 ] = thisScore - p3x5;
                    m3x5[ thisCodon ][ 10 * thisCodon2 + 8 ] = thisScore - p3x5;
                    m3x5[ thisCodon ][ 10 * thisCodon2 + 9 ] = thisScore - p3x5;

                    m3x4[ thisCodon ][ 4 * thisCodon2 + 0 ] = thisScore - p3x4;
                    m3x4[ thisCodon ][ 4 * thisCodon2 + 1 ] = thisScore - p3x4;
                    m3x4[ thisCodon ][ 4 * thisCodon2 + 2 ] = thisScore - p3x4;
                    m3x4[ thisCodon ][ 4 * thisCodon2 + 3 ] = thisScore - p3x4;

                    // d1 is 1
                    max100 = Max( max100, _cdnScoreMatrix[ thisCodon ][ 16 * d1 + 4 * d2 + d3 ] );
                    max010 = Max( max010, _cdnScoreMatrix[ thisCodon ][ 16 * d2 + 4 * d1 + d3 ] );
                    max001 = Max( max001, _cdnScoreMatrix[ thisCodon ][ 16 * d2 + 4 * d3 + d1 ] );

                    // d1 and d2 are 1
                    max110 = Max( max110, _cdnScoreMatrix[ thisCodon ][ 16 * d1 + 4 * d2 + d3 ] );
                    max101 = Max( max101, _cdnScoreMatrix[ thisCodon ][ 16 * d1 + 4 * d3 + d2 ] );
                    max011 = Max( max011, _cdnScoreMatrix[ thisCodon ][ 16 * d3 + 4 * d1 + d2 ] );
                }

                m3x2[ thisCodon ][ 3 * partialCodon + 0 ] = max110 - p3x2;
                m3x2[ thisCodon ][ 3 * partialCodon + 1 ] = max101 - p3x2;
                m3x2[ thisCodon ][ 3 * partialCodon + 2 ] = max011 - p3x2;
            }

            m3x1[ thisCodon ][ 3 * d1 + 0 ] = max100 - p3x1;
            m3x1[ thisCodon ][ 3 * d1 + 1 ] = max010 - p3x1;
            m3x1[ thisCodon ][ 3 * d1 + 2 ] = max001 - p3x1;
        }
    }
    return { "3x1": m3x1, "3x2": m3x2, "3x4": m3x4, "3x5": m3x5 };
}

function pSM2cSM(_scorematrix, _letters)
{
    LoadFunctionLibrary( "GrabBag" );

    _cdnScoreMatrix  = { 65,65 };
    _mapping      = mapStrings( _hyphyAAOrdering, _letters );
    for ( _k = 0; _k < 64; _k += 1 ) {
        _mappedK = _mapping[ _Genetic_Code[ _k ] ];
        if ( _mappedK >= 0) {
            for ( _k2 = _k; _k2 < 64; _k2 += 1 ) {
                _mappedK2 = _mapping[ _Genetic_Code[ _k2 ] ];
                if ( _mappedK2 >= 0 ) {
                    _aScore = _scorematrix[ _mappedK ][ _mappedK2 ];
                    if ( _mappedK == _mappedK2 && _k2 > _k ) {
                        _aScore = _aScore - 1;
                    }
                } else {
                    // stop codons don't match anything
                    _aScore = -1e4;
                }
                _cdnScoreMatrix[ _k ][ _k2 ] = _aScore;
                _cdnScoreMatrix[ _k2 ][ _k ] = _aScore;
            }
        } else {
            for ( _k2 = _k; _k2 < 64; _k2 += 1 ) {
                _mappedK2 = _mapping[ _Genetic_Code[ _k2 ] ];
                if ( _mappedK2 < 0 ) {
                    // don't penalize stop codons matching themselves
                    _cdnScoreMatrix[ _k ][ _k2 ] = 0;
                    _cdnScoreMatrix[ _k2 ][ _k ] = 0;
                } else {
                    _cdnScoreMatrix[ _k ][ _k2 ] = -1e4;
                    _cdnScoreMatrix[ _k2 ][ _k ] = -1e4;
                }
            }
        }
    }

    return _cdnScoreMatrix;
}
