LoadFunctionLibrary("libv3/UtilityFunctions.bf");
LoadFunctionLibrary("convenience/regexp.bf");

/**
 * @name io.checkAssertion
 * @param statement
 * @param error_msg
 */
function io.checkAssertion(statement, error_msg) {
    ExecuteCommands("assert (`statement`, error_msg)");
}

/**
 * @name io.prompt_user
 * @param statement
 * @param default
 * @param lower_bound
 * @param upper_bound
 * @param is_integer
 */
lfunction io.prompt_user(prompt,
    default, lower_bound, upper_bound, is_integer) {
    value = lower_bound - 1;

    while (value < lower_bound || value > upper_bound) {

        fprintf(stdout, prompt, " (permissible range = [", lower_bound, ",", upper_bound, "], default value = ",
            default);
        if (is_integer) {
            fprintf(stdout, ", integer");
        }
        fprintf(stdout, "): ");
        fscanf(stdin, "String", str_val);

        if (Abs(str_val) == 0) {
            value = 0 +
                default;
        } else {
            value = 0 + str_val;
        }
        if (is_integer) {
            value = value $ 1;
        }
    }
    return value;
}

/**
 * @name io.spoolLF
 * @param lf_id
 * @param trunk_path
 * @param tag
 * @returns nothing
 */
lfunction io._reportMessageHelper(analysis, text) {
    if (Abs(analysis)) {
        return "[`analysis`] `text`";
    } else {
        return text;
    }
}

/** 
 * @name io.spool_json
 * @param json
 * @param file
 */
lfunction io.spool_json(json, file) {
    utility.toggleEnvVariable("USE_JSON_FOR_MATRIX", 1);
    if (Type(file) == "String") {
        fprintf(file, CLEAR_FILE, json);
    } else {
        fprintf(stdout, "\n", json, "\n");
    }
    utility.toggleEnvVariable("USE_JSON_FOR_MATRIX", None);
}

/** 
 * @name io.reportProgressMessage
 * @param analysis
 * @param text
 */
lfunction io.reportProgressMessage(analysis, text) {
    fprintf(stdout, io._reportMessageHelper(analysis, text), "\n");
}

/** 
 * @name io.reportAnalysisStageMD
 * @param stage
 */
lfunction io.reportAnalysisStageMD(stage) {
    fprintf(stdout, "\n>", stage, "\n\n");
}

/** 
 * @name io.reportProgressMessageMD
 * @param analysis
 * @param stage
 * @param text
 */
lfunction io.reportProgressMessageMD(analysis, stage, text) {
    if (Abs(cache) == 0) {
        cache = {};
    }
    advance = TRUE;
    utility.dict.ensure_key(cache, analysis);

    if ((cache[analysis])[stage]) {
        advance = FALSE;
    }
    (cache[analysis])[stage] += 1;

    if (advance) {
        if (Abs(cache[analysis]) == 1) {
            fprintf(stdout, "\n");
        }
        fprintf(stdout, "\n### ", text, "\n");
    } else {
        fprintf(stdout, text, "\n");
    }
}

/**
 * Reports stats generated from math.gather_descriptive_stats
 * @name io.reportStatsMD
 * @param label - Typically the name of the method used
 * @param stats - The stats dict generated by math.gather_descriptive_stats
 */
lfunction io.reportStatsMD(_label, _stats) {

    _table_output_options = {
        "header": 1,
        "min-column-width": 16,
        "align": "center",
        "column-widths": {
            "0": 16,
            "1": 16,
            "2": 16,
            "3": 16,
            "4": 16,
            "5": 16,
            "6": 19
        }
    };

    _results = {
        Abs(_stats),
        2
    };
    _keys = utility.keys(_stats);

    for (_k = 0; _k < Abs(_stats); _k = _k + 1) {
        _results[_k][0] = _keys[_k];
        _results[_k][1] = _stats[_keys[_k]];
    }

    _header = {
        2,
        1
    };
    _header[0] = "Metric";
    _header[1] = "Value";
    fprintf(stdout, io.format_table_row(_header, _table_output_options));
    _table_output_options["header"] = FALSE;

    for (_k = 0; _k < Abs(_stats); _k = _k + 1) {
        _tmp_matrix = {
            2,
            1
        };
        _tmp_matrix[0] = _results[_k][0];
        _tmp_matrix[1] = Format(_results[_k][1], 3, 3);
        fprintf(stdout, io.format_table_row(_tmp_matrix, _table_output_options));
    }

    return 0;
}

/** 
 * @name io.reportProgressBar
 * @param analysis
 * @param text
 */
lfunction io.reportProgressBar(analysis, text) {
    SetParameter(STATUS_BAR_STATUS_STRING, io._reportMessageHelper(analysis, text), 0);
}

/** 
 * @name io.validate_a_list_of_files
 * @param list
 */
function io.validate_a_list_of_files(list) {
    io.validate_a_list_of_files.result = {};
    for (io.validate_a_list_of_files.i = 0; io.validate_a_list_of_files.i < Rows(list) * Columns(list); io.validate_a_list_of_files.i += 1) {
        if (Abs(list[io.validate_a_list_of_files.i])) {
            io.validate_a_list_of_files.fn = list[io.validate_a_list_of_files.i];
            io.checkAssertion("!io.validate_a_list_of_files.fn", "HyPhy cannot open '" + io.validate_a_list_of_files.fn + "' for reading");
            io.validate_a_list_of_files.result + io.validate_a_list_of_files.fn;
        }
    }
    return io.validate_a_list_of_files.result;
}

/** 
 * @name io.format_object
 * @param object
 * @param options
 */
lfunction io.format_object(object, options) {

    if (Type(object) == "String") {
        return object;
    }
    if (Type(object) == "Number") {
        if (None != options) {
            if (Abs(options["number-precision"]) > 0) {
                return Eval("Format (`&object`, 0, " + options["number-precision"] + ")");
            }
        }
    }

    return "" + object;
}

/** 
 * @name io.format_table_row
 * @param row
 * @param options
 */
lfunction io.format_table_row(row, options) {

    if (None == options) {
        options = {};
    }

    cells = utility.map(row, "_value_", "io.format_object(_value_, `&options`)");

    min_width = Max(3, options["min-column-width"]);

    underline_chars = {
        {
            "-",
            "-",
            "-"
        }
    };
    dim = utility.array1D(cells);

    row = "";
    row * 128;
    if (options["header"]) {
        underlines = "";
        underlines * 128;
        widths = {};

        if (options["align"] == "center") {
            underline_chars[0] = ':';
            underline_chars[2] = ':';
        } else {
            if (options["align"] == "right") {
                underline_chars[2] = ':';
            }

        }
        for (i = 0; i < dim; i += 1) {
            content_width = Abs(cells[i]);
            cell_width = Max(min_width, content_width);
            widths + cell_width;
            row * "|";
            padding = cell_width - content_width;

            for (k = 0; k < padding$2; k += 1) {
                row * " ";
            }
            row * cells[i];
            for (k = 0; k < padding - padding$2; k += 1) {
                row * " ";
            }
            underlines * "|";
            underlines * underline_chars[0];
            for (k = 1; k < cell_width - 1; k += 1) {
                underlines * underline_chars[1];
            }
            underlines * underline_chars[2];
        }
        row * "|";
        underlines * "|";
        underlines * 0;
        row * "\n";
        row * underlines;
        row * "\n";
        options["column-widths"] = widths;
    } else {
        for (i = 0; i < dim; i += 1) {
            content_width = Abs(cells[i]);
            cell_width = (options["column-widths"])[i];

            row * "|";
            if (cell_width <= content_width + 3) {
                cells[i] = (cells[i])[0][cell_width - 4] + "...";
                padding = 0;
            } else {
                padding = cell_width - content_width;
            }
            for (k = 0; k < padding$2; k += 1) {
                row * " ";
            }
            row * cells[i];
            for (k = 0; k < padding - padding$2; k += 1) {
                row * " ";
            }
        }
        row * "|\n";
    }
    row * 0;
    return row;
}

/**
 * @name io.get_a_list_of_files
 * @param filename
 */
function io.get_a_list_of_files(filename) {
    if (Type(filename) == "String") {
        if (!filename) { // filename exists
            fscanf(filename, REWIND, "Lines", io.get_a_list_of_files.list);
            return io.validate_a_list_of_files(io.get_a_list_of_files.list);
        }
    }

    io.get_a_list_of_files.result = {};
    io.printAndUnderline("Enter paths to files (blank line to end entry)", "-");
    while (1) {
        fprintf(stdout, "* File ", Abs(io.get_a_list_of_files.result) + 1, " [relative path `PATH_TO_CURRENT_BF`]:");
        io.get_a_list_of_files.current_path = "";
        fscanf(stdin, "String", io.get_a_list_of_files.current_path);
        if (Abs(io.get_a_list_of_files.current_path)) {
            io.checkAssertion("! io.get_a_list_of_files.current_path", "HyPhy cannot open '" + io.get_a_list_of_files.current_path + "' for reading");
        } else {
            break;
        }
        io.get_a_list_of_files.result + io.get_a_list_of_files.current_path;
    }
}

/**
 * @name io.displayAnalysisBanner
 * @param analysis_info
 */
lfunction io.displayAnalysisBanner(analysis_info) {
    if (io.hasStringKey("info", analysis_info)) {
        io.printAndUnderline("Analysis Description", "-");
        fprintf(stdout, io.formatLongStringToWidth(analysis_info["info"], 72), "\n");
    }
    if (io.hasStringKey("requirements", analysis_info)) {
        fprintf(stdout, "\n- __Requirements__: ");
        fprintf(stdout, io.formatLongStringToWidth(analysis_info["requirements"], 72), "\n");
    }
    if (io.hasStringKey("reference", analysis_info)) {
        fprintf(stdout, "\n- __Citation__: ");
        fprintf(stdout, io.formatLongStringToWidth(analysis_info["reference"], 72), "\n");
    }
    if (io.hasStringKey("authors", analysis_info)) {
        fprintf(stdout, "\n- __Written by__: ");
        fprintf(stdout, io.formatLongStringToWidth(analysis_info["authors"], 72), "\n");
    }
    if (io.hasStringKey("contact", analysis_info)) {
        fprintf(stdout, "\n- __Contact Information__: ");
        fprintf(stdout, io.formatLongStringToWidth(analysis_info["contact"], 72), "\n");
    }
    if (io.hasStringKey("version", analysis_info)) {
        fprintf(stdout, "\n- __Analysis Version__: ");
        fprintf(stdout, io.formatLongStringToWidth(analysis_info["version"], 72), "\n");
    }
    fprintf(stdout, "\n");

    return None;
}

/**
 * @name io.hasStringKey
 * @param key
 * @param dict
 */
lfunction io.hasStringKey(key, dict) {
    return Type(dict[key]) == "String";
}

/**
 * @name io.spoolLF
 * @param lf_id
 * @param trunk_path
 * @param tag
 * @returns nothing
 */
lfunction io.spoolLF(lf_id, trunk_path, tag) {

    Export(__lf_spool, ^ lf_id);
    if (tag == None) {
        tag = lf_id;
    }
    fprintf(trunk_path + "." + tag + ".bf", CLEAR_FILE, __lf_spool);
}

/**
 * @name io.printAndUnderline
 * @param string
 * @param char
 * @returns nothing
 */
lfunction io.printAndUnderline(string, char) {
    fprintf(stdout, "\n", string, "\n");
    buffer = "";
    buffer * (1 + Abs(string));
    for (k = 0; k < Abs(string); k += 1) {
        buffer * char[0];
    }
    buffer * 0;
    fprintf(stdout, buffer, "\n");
}

/**
 * @name io.formatLongStringToWidth
 * @param {String} string
 * @param {Number} width
 * @returns {String} formatted string
 */
function io.formatLongStringToWidth(string, width) {
    words = regexp.split(string, "[\\ \n]+");
    lines = {};

    current_line = "";
    words_in_current_line = 0;
    for (i = 0; i < Abs(words); i += 1) {
        if (words_in_current_line == 0) {
            current_line = words[i];
            words_in_current_line = 1;
        } else {
            if (Abs(current_line) + Abs(words[i]) + 1 <= width) {
                words_in_current_line += 1;
                current_line += " " + words[i];
            } else {
                lines + current_line;
                words_in_current_line = 0;
                current_line = "";
                i = i - 1;
            }
        }
    }

    if (words_in_current_line) {
        lines + current_line;
    }

    return Join("\n", lines);
}
